#include <coll/limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define COLL_MAP_NAME(x) UTIL_CONCAT(COLL_MAP_TYPE,x)

typedef struct COLL_MAP_NAME(Private_s) {

   collComparator        cmp;
   unsigned              count;
#ifdef STATIC_ALLOCATION
   COLL_MAP_NAME(Pair)   pairs[COLL_MAP_ITEM_MAX_COUNT];
#else
   unsigned              limit;
   COLL_MAP_NAME(Pair) * pairs;
#endif

} COLL_MAP_NAME(Private);

#ifdef STATIC_ALLOCATION
static COLL_MAP_NAME(Private) COLL_MAP_NAME(Maps)[COLL_MAP_NAME(MAX_COUNT)];
static unsigned int COLL_MAP_NAME(Next) = 0;
unsigned int COLL_MAP_NAME(LimitsCountMax)     = 0;
unsigned int COLL_MAP_NAME(LimitsPairCountMax) = 0;
#endif

typedef int ( * PVoidComparator )( const void *, const void * );

COLL_MAP_TYPE COLL_MAP_NAME(_new)( collComparator cmp ) {
#ifdef STATIC_ALLOCATION
   if( COLL_MAP_NAME(Next) == COLL_MAP_NAME(MAX_COUNT)) {
      fprintf( stderr, "%s:%d:%s_reserve: out of memory!\n", #COLL_MAP_TYPE, __FILE__, __LINE__ );
      return NULL;
   }
   COLL_MAP_NAME(Private) * This = &Maps[NextMap++];
#else
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)malloc( sizeof( COLL_MAP_NAME(Private)));
#endif
   This->cmp   = cmp;
   This->count = 0;
#ifndef STATIC_ALLOCATION
   This->limit = 100;
   This->pairs = (COLL_MAP_NAME(Pair)*)malloc( This->limit * sizeof( COLL_MAP_NAME(Pair)));
#endif
   return (COLL_MAP_TYPE)This;
}

void COLL_MAP_NAME(_delete)( COLL_MAP_TYPE * self ) {
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)*self;
   This->count = 0;
#ifndef STATIC_ALLOCATION
   free( This->pairs );
   This->limit = 0;
   This->pairs = NULL;
   free( This );
#endif
   *self = NULL;
}

void COLL_MAP_NAME(_clear)( COLL_MAP_TYPE self ) {
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)self;
   This->count = 0;
#ifndef STATIC_ALLOCATION
   This->limit = 100;
   This->pairs = (COLL_MAP_NAME(Pair)*)realloc( This->pairs, This->limit * sizeof( COLL_MAP_NAME(Pair)));
#endif
}

bool COLL_MAP_NAME(_put)(
   COLL_MAP_TYPE          self,
   COLL_MAP_NAME(Key  )   key,
   COLL_MAP_NAME(Value)   value,
   COLL_MAP_NAME(Pair ) * previousPair )
{
   COLL_MAP_NAME(Private) * This    = (COLL_MAP_NAME(Private)*)self;
   COLL_MAP_NAME(Pair) *    oldPair = NULL;
   COLL_MAP_NAME(Pair)      newPair;

   if( self == NULL ) {
      fprintf( stderr, "Please call collMap_new before!\n" );
      return false;
   }
   newPair.key   = key;
   newPair.value = NULL;
   oldPair =
      bsearch(
         &newPair, This->pairs, This->count, sizeof( COLL_MAP_NAME(Pair)),
         (PVoidComparator)This->cmp );
   if( oldPair ) {
      if( previousPair ) {
         *previousPair = *oldPair; 
      }
      oldPair->key   = key;
      oldPair->value = value;
      return true;
   }
#ifdef STATIC_ALLOCATION
   if( This->count == COLL_MAP_ITEM_MAX_COUNT ) {
      fprintf( stderr, "%s:%d:%s_put: out of memory!\n", __FILE__, __LINE__, #COL_MAP_TYPE );
      return false;
   }
#else
   if( This->count == This->limit ) {
      This->limit += 100;
      This->pairs = (COLL_MAP_NAME(Pair)*)
         realloc( This->pairs, This->limit * sizeof( COLL_MAP_NAME(Pair)));
   }
#endif
   oldPair = (COLL_MAP_NAME(Pair)*)(This->pairs + This->count++);
   oldPair->key   = key;
   oldPair->value = value;
   qsort( This->pairs, This->count, sizeof( COLL_MAP_NAME(Pair)), (PVoidComparator)This->cmp );
   if( previousPair ) {
      previousPair->key   = NULL; 
      previousPair->value = NULL; 
   }
   return false;
}

bool COLL_MAP_NAME(_remove)(
   COLL_MAP_TYPE         self,
   COLL_MAP_NAME(Key )   key,
   COLL_MAP_NAME(Pair) * previousPair )
{
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)self;
   COLL_MAP_NAME(Pair)      pair;
   unsigned                 i;

   pair.key   = key;
   pair.value = NULL;
   for( i = 0; i < This->count; ++i ) {
      if( 0 == This->cmp( This->pairs + i, &pair )) {
         if( previousPair ) {
            *previousPair = This->pairs[i];
         }
         memmove(
            This->pairs + i,
            This->pairs + i + 1,
            ( This->count - i - 1 )*sizeof( COLL_MAP_NAME(Pair)));
         --This->count;
         return true;
      }
   }
   return false;
}

unsigned int COLL_MAP_NAME(_size)( COLL_MAP_TYPE self ) {
   return ((COLL_MAP_NAME(Private)*)self)->count;
}

COLL_MAP_NAME(Value) COLL_MAP_NAME(_get)( COLL_MAP_TYPE self, COLL_MAP_NAME(Key) key ) {
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)self;
   COLL_MAP_NAME(Pair) *    pair;
   COLL_MAP_NAME(Pair)      keyPair;

   keyPair.key   = key;
   keyPair.value = NULL;
   pair =
      bsearch(
         &keyPair,
         This->pairs,
         This->count,
         sizeof( COLL_MAP_NAME(Pair)),
         (PVoidComparator)This->cmp );
   if( pair ) {
      return pair->value;
   }
   return 0;
}

bool COLL_MAP_NAME(_hasKey)( COLL_MAP_TYPE self, COLL_MAP_NAME(Key) key ) {
   return COLL_MAP_NAME(_get)( self, key ) != NULL;
}

collForeachResult COLL_MAP_NAME(_foreach)(
   COLL_MAP_TYPE       self,
   collForeachFunction fn,
   void *              userData )
{
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)self;
   collForeach              context;
   context.user = userData;
   for( context.index = 0; context.index < This->count; ++context.index ) {
      context.item  = This->pairs + context.index;
      if( !fn( &context ) ) {
         break;
      }
   }
   return context.retVal;
}

COLL_MAP_NAME(Pairs) COLL_MAP_NAME(_values)( COLL_MAP_TYPE self ) {
   COLL_MAP_NAME(Private) * This = (COLL_MAP_NAME(Private)*)self;
   return This->pairs;
}
