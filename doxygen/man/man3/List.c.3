.TH "src/coll/List.c" 3 "Mon Nov 16 2015" "Version 0.0.0" "dcrud" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/coll/List.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <coll/List\&.h>\fP
.br
\fC#include <coll/limits\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBcollPrivateList_s\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBcollPrivateList_s\fP \fBcollPrivateList\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "collList \fBcollList_reserve\fP ()"
.br
.ti -1c
.RI "void \fBcollList_clear\fP (collList self)"
.br
.ti -1c
.RI "void \fBcollList_add\fP (collList self, \fBcollListItem\fP item)"
.br
.ti -1c
.RI "\fBbool\fP \fBcollList_remove\fP (collList self, \fBcollListItem\fP item)"
.br
.ti -1c
.RI "unsigned int \fBcollList_size\fP (collList self)"
.br
.ti -1c
.RI "\fBcollForeachResult\fP \fBcollList_foreach\fP (collList self, \fBcollForeachFunction\fP fn, void *userData)"
.br
.ti -1c
.RI "void \fBcollList_release\fP (collList *self)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBcollPrivateList_s\fP  \fBcollPrivateList\fP"

.SH "Function Documentation"
.PP 
.SS "void collList_add (collListself, \fBcollListItem\fPitem)"

.PP
Definition at line 53 of file List\&.c\&.
.PP
.nf
53                                                       {
54    collPrivateList * This = (collPrivateList *)self;
55 #ifdef STATIC_ALLOCATION
56    if( This->count == COLL_LIST_ITEM_MAX_COUNT ) {
57       fprintf( stderr, "%s:%d:collList_add: out of memory!\n", __FILE__, __LINE__ );
58       return;
59    }
60 #else
61    if( This->count == This->limit ) {
62       This->limit += 100;
63       This->items = (collListItem *)realloc( This->items, This->limit * sizeof( collListItem ) );
64    }
65 #endif
66    This->items[This->count++] = item;
67 }
.fi
.SS "void collList_clear (collListself)"

.PP
Definition at line 44 of file List\&.c\&.
.PP
.nf
44                                      {
45    collPrivateList * This = (collPrivateList *)self;
46    This->count = 0;
47 #ifndef STATIC_ALLOCATION
48    This->limit = 100;
49    This->items = (collListItem *)realloc( This->items, This->limit * sizeof( collListItem ));
50 #endif
51 }
.fi
.SS "\fBcollForeachResult\fP collList_foreach (collListself, \fBcollForeachFunction\fPfn, void *userData)"

.PP
Definition at line 89 of file List\&.c\&.
.PP
.nf
89                                                                                              {
90    collPrivateList * This = (collPrivateList *)self;
91    collForeach context;
92    context\&.user = userData;
93    for( context\&.index = 0; context\&.index < This->count; ++context\&.index ) {
94       context\&.item = This->items[context\&.index];
95       if( !fn( &context ) ) {
96          break;
97       }
98    }
99    return context\&.retVal;
100 }
.fi
.SS "void collList_release (collList *self)"

.PP
Definition at line 102 of file List\&.c\&.
.PP
.nf
102                                          {
103    collPrivateList * This = (collPrivateList *)*self;
104    This->count = 0;
105 #ifndef STATIC_ALLOCATION
106    free( This->items );
107    This->limit = 0;
108    This->items = NULL;
109    free( This );
110 #endif
111    *self = NULL;
112 }
.fi
.SS "\fBbool\fP collList_remove (collListself, \fBcollListItem\fPitem)"

.PP
Definition at line 69 of file List\&.c\&.
.PP
.nf
69                                                          {
70    collPrivateList * This = (collPrivateList *)self;
71    unsigned i;
72    for( i = 0; i < This->count; ++i ) {
73       if( This->items[i] == item ) {
74          memmove(
75             This->items + i,
76             This->items + i + 1,
77             ( This->count - i - 1 )*sizeof( collListItem ));
78          --This->count;
79          return true;
80       }
81    }
82    return false;
83 }
.fi
.SS "collList collList_reserve ()"

.PP
Definition at line 26 of file List\&.c\&.
.PP
.nf
26                             {
27 #ifdef STATIC_ALLOCATION
28    if( NextList == COLL_LIST_MAX_COUNT ) {
29       fprintf( stderr, "%s:%d:collList_reserve: out of memory!\n", __FILE__, __LINE__ );
30       return NULL;
31    }
32    collPrivateList * This = &Lists[NextList++];
33 #else
34    collPrivateList * This = (collPrivateList *)malloc( sizeof( collPrivateList ));
35 #endif
36    This->count = 0;
37 #ifndef STATIC_ALLOCATION
38    This->limit = 100;
39    This->items = (collListItem *)malloc( This->limit * sizeof( collListItem ));
40 #endif
41    return (collList)This;
42 }
.fi
.SS "unsigned int collList_size (collListself)"

.PP
Definition at line 85 of file List\&.c\&.
.PP
.nf
85                                             {
86    return ((collPrivateList *)self )->count;
87 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for dcrud from the source code\&.
