.TH "src/coll/Map.c" 3 "Mon Nov 16 2015" "Version 0.0.0" "dcrud" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/coll/Map.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <coll/Map\&.h>\fP
.br
\fC#include <coll/limits\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBcollMapPair_s\fP"
.br
.ti -1c
.RI "struct \fBcollPrivateMap_s\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBcollMapPair_s\fP \fBcollMapPair\fP"
.br
.ti -1c
.RI "typedef struct \fBcollPrivateMap_s\fP \fBcollPrivateMap\fP"
.br
.ti -1c
.RI "typedef int(* \fBPVoidComparator\fP )(const void *, const void *)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "collMap \fBcollMap_reserve\fP (\fBcollComparator\fP cmp)"
.br
.ti -1c
.RI "void \fBcollMap_clear\fP (collMap self)"
.br
.ti -1c
.RI "\fBcollMapValue\fP \fBcollMap_put\fP (collMap self, \fBcollMapKey\fP key, \fBcollMapValue\fP value)"
.br
.ti -1c
.RI "\fBcollMapValue\fP \fBcollMap_get\fP (collMap self, \fBcollMapKey\fP key)"
.br
.ti -1c
.RI "\fBcollMapValue\fP \fBcollMap_remove\fP (collMap self, \fBcollMapKey\fP key)"
.br
.ti -1c
.RI "unsigned int \fBcollMap_size\fP (collMap self)"
.br
.ti -1c
.RI "\fBcollForeachMapResult\fP \fBcollMap_foreach\fP (collMap self, \fBcollForeachMapFunction\fP fn, void *userData)"
.br
.ti -1c
.RI "void \fBcollMap_release\fP (collMap *self)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBcollMapPair_s\fP  \fBcollMapPair\fP"

.SS "typedef struct \fBcollPrivateMap_s\fP  \fBcollPrivateMap\fP"

.SS "typedef int( *  PVoidComparator)(const void *, const void *)"

.PP
Definition at line 34 of file Map\&.c\&.
.SH "Function Documentation"
.PP 
.SS "void collMap_clear (collMapself)"

.PP
Definition at line 55 of file Map\&.c\&.
.PP
.nf
55                                    {
56    collPrivateMap * This = (collPrivateMap *)self;
57    This->count = 0;
58 #ifndef STATIC_ALLOCATION
59    This->limit = 100;
60    This->pairs = (collMapPair *)realloc( This->pairs, This->limit * sizeof( collMapPair ) );
61 #endif
62 }
.fi
.SS "\fBcollForeachMapResult\fP collMap_foreach (collMapself, \fBcollForeachMapFunction\fPfn, void *userData)"

.PP
Definition at line 144 of file Map\&.c\&.
.PP
.nf
144                                                                                                  {
145    collPrivateMap * This = (collPrivateMap *)self;
146    collForeachMap   context;
147    context\&.user = userData;
148    for( context\&.index = 0; context\&.index < This->count; ++context\&.index ) {
149       context\&.key   = This->pairs[context\&.index]\&.key;
150       context\&.value = This->pairs[context\&.index]\&.value;
151       if( !fn( &context ) ) {
152          break;
153       }
154    }
155    return context\&.retVal;
156 }
.fi
.SS "\fBcollMapValue\fP collMap_get (collMapself, \fBcollMapKey\fPkey)"

.PP
Definition at line 99 of file Map\&.c\&.
.PP
.nf
99                                                          {
100    collPrivateMap * This = (collPrivateMap *)self;
101    collMapPair *    pair;
102    collMapPair      keyPair;
103 
104    keyPair\&.key   = key;
105    keyPair\&.value = NULL;
106    pair =
107       bsearch(
108          &keyPair,
109          This->pairs,
110          This->count,
111          sizeof( collMapPair ),
112          (PVoidComparator)This->cmp );
113    if( pair ) {
114       return pair->value;
115    }
116    return 0;
117 }
.fi
.SS "\fBcollMapValue\fP collMap_put (collMapself, \fBcollMapKey\fPkey, \fBcollMapValue\fPvalue)"

.PP
Definition at line 64 of file Map\&.c\&.
.PP
.nf
64                                                                              {
65    collPrivateMap * This = (collPrivateMap *)self;
66    collMapPair *    pair;
67    collMapValue     oldValue = NULL;
68    collMapPair      keyPair;
69 
70    keyPair\&.key   = key;
71    keyPair\&.value = NULL;
72    pair =
73       bsearch(
74          &keyPair, This->pairs, This->count, sizeof( collMapPair ), (PVoidComparator)This->cmp );
75    if( pair ) {
76       oldValue = pair->value;
77       pair->value = value;
78    }
79    else {
80 #ifdef STATIC_ALLOCATION
81    if( This->count == COLL_MAP_ITEM_MAX_COUNT ) {
82       fprintf( stderr, "%s:%d:collMap_put: out of memory!\n", __FILE__, __LINE__ );
83       return NULL;
84    }
85 #else
86    if( This->count == This->limit ) {
87       This->limit += 100;
88       This->pairs = (collMapPair *)realloc( This->pairs, This->limit * sizeof( collMapPair ));
89    }
90 #endif
91       pair = (collMapPair *)(This->pairs + This->count++);
92       pair->key   = key;
93       pair->value = value;
94       qsort( This->pairs, This->count, sizeof( collMapPair ), (PVoidComparator)This->cmp );
95    }
96    return oldValue;
97 }
.fi
.SS "void collMap_release (collMap *self)"

.PP
Definition at line 158 of file Map\&.c\&.
.PP
.nf
158                                        {
159    collPrivateMap * This = (collPrivateMap *)*self;
160    This->count = 0;
161 #ifndef STATIC_ALLOCATION
162    free( This->pairs );
163    This->limit = 0;
164    This->pairs = NULL;
165    free( This );
166 #endif
167    *self = NULL;
168 }
.fi
.SS "\fBcollMapValue\fP collMap_remove (collMapself, \fBcollMapKey\fPkey)"

.PP
Definition at line 119 of file Map\&.c\&.
.PP
.nf
119                                                             {
120    collPrivateMap * This = (collPrivateMap *)self;
121    unsigned         i;
122    collMapPair      keyPair;
123 
124    keyPair\&.key   = key;
125    keyPair\&.value = NULL;
126    for( i = 0; i < This->count; ++i ) {
127       if( 0 == This->cmp( This->pairs + i, &keyPair )) {
128          collMapValue retVal = This->pairs[i]\&.value;
129          memmove(
130             This->pairs + i,
131             This->pairs + i + 1,
132             ( This->count - i - 1 )*sizeof( collMapPair ));
133          --This->count;
134          return retVal;
135       }
136    }
137    return NULL;
138 }
.fi
.SS "collMap collMap_reserve (\fBcollComparator\fPcmp)"

.PP
Definition at line 36 of file Map\&.c\&.
.PP
.nf
36                                               {
37 #ifdef STATIC_ALLOCATION
38    if( NextMap == COLL_MAP_MAX_COUNT ) {
39       fprintf( stderr, "%s:%d:collMap_reserve: out of memory!\n", __FILE__, __LINE__ );
40       return NULL;
41    }
42    collPrivateMap * This = &Maps[NextMap++];
43 #else
44    collPrivateMap * This = (collPrivateMap *)malloc( sizeof( collPrivateMap ));
45 #endif
46    This->cmp   = cmp;
47    This->count = 0;
48 #ifndef STATIC_ALLOCATION
49    This->limit = 100;
50    This->pairs = (collMapPair *)malloc( This->limit * sizeof( collMapPair ));
51 #endif
52    return (collMap)This;
53 }
.fi
.SS "unsigned int collMap_size (collMapself)"

.PP
Definition at line 140 of file Map\&.c\&.
.PP
.nf
140                                           {
141    return ((collPrivateMap *)self)->count;
142 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for dcrud from the source code\&.
